
import os
import sys
import json
import numpy as np

from sana_geo import Polygon, Point

def get_fullpath(f):
    return os.path.abspath(os.path.expanduser(f))

def create_directory(f):
    if not os.path.exists(os.path.dirname(f)):
        os.makedirs(os.path.dirname(f))

def convert_fname(ifname, ext="", suffix="", odir="", rdir=""):

    # modify the basename and the filetype
    if ext == "":
        ext = os.path.splitext(ifname)[1]
    ofname = os.path.splitext(os.path.basename(ifname))[0]
    if suffix == "":
        ofname += ext
    else:
        ofname = '%s%s%s' % (ofname, suffix, ext)

    # modify the dirpath
    if odir == "":
        d = os.path.dirname(ifname)
    elif rdir == "":
        d = odir
    else:
        d = os.path.dirname(ifname).replace(rdir, odir)

    return get_fullpath(os.path.join(d, ofname))

def read_list_file(list_f):
    f = get_fullpath(list_f)
    return [get_fullpath(l.rstrip()) for l in open(f, 'r')]

def read_metrics_file(f):
    if not os.path.exists(f):
        return "", ["",""], ["",""], ["",""], "", ""
    fp = open(f, 'r')
    a, l0, l1, c0, c1, ds0, ds1, tt, st = \
        fp.read().split('\n')[0].split(',')

    # set crop_loc first
    angle = "" if a == "" else float(a)
    loc = ["",""] if l0 == "" else Point(float(l0), float(l1), False, 0)
    crop_loc = ["",""] if c0 == "" else Point(float(c0), float(c1), False, 0)
    ds = ["",""] if ds0 == "" else Point(float(ds0), float(ds1), False, 0)
    tissue_threshold = "" if tt == "" else float(tt)
    stain_threshold = "" if st == "" else float(st)
    return angle, loc, crop_loc, ds, tissue_threshold, stain_threshold

def write_metrics_file(f, angle=None, loc=None, crop_loc=None, ds=None,
                       tissue_threshold=None, stain_threshold=None):
    l, c, d = [["", ""]]*3
    a, tt, st = [""]*3
    if os.path.exists(f):
        a, l, c, d, tt, st = read_metrics_file(f)
    if not angle is None: a = angle
    if not loc is None: l = loc
    if not crop_loc is None: c = crop_loc
    if not ds is None: d = ds
    if not tissue_threshold is None: tt = tissue_threshold
    if not stain_threshold is None: st = stain_threshold
    fp = open(f, 'w')
    fp.write('%s,%s,%s,%s,%s,%s,%s,%s,%s\n' % \
             (a, l[0], l[1], c[0], c[1], d[0], d[1], tt, st))
    fp.close()

def anno_to_json(anno, class_name=None, anno_name=None):
    verts = []
    for i in range(anno.shape[0]):
        verts.append([anno[i][0], anno[i][1]])
    annotation = {
        "type": "Feature",
        "id": "PathAnnotationObject",
        "geometry": {
          "type": "Polygon",
          "coordinates": [verts]
        },
        "properties": {
          "name": anno_name,
          "classification": {
            "name": class_name,
          },
        }
    }
    return annotation

# sometimes the json files generated by qupath 7 unreadable bytes
# this function checks if they exist, and removes them from the file
def fix_annotations(ifname):
    fp = open(ifname, 'rb')
    data = fp.read()
    fp.close()

    ind = data.find(b'[\n')
    if ind == -1:
        return

    fp = open(ifname, 'wb')
    fp.write(data[ind:])
    fp.close()

def read_annotations(ifname, class_name=None):

    # remove unnecessary bytes at beginning of file if they exist
    fix_annotations(ifname)

    # prepare the input file
    fp = open(ifname, 'r')

    # load the data
    try:
        data = json.loads(fp.read())
    except:
        return [], [], []

    # TODO: handle the multipolygon better than this, why is there sometimes 2 sets of coords
    annotations = []
    class_names = []
    anno_names = []
    for annotation in data:
        if class_name is not None and  \
            'classification' in annotation['properties']:
            if annotation['properties']['classification']['name'] != class_name:
                continue
        geo = annotation['geometry']
        if geo['type'] == 'MultiPolygon':
            coords_list = geo['coordinates']
        elif geo['type'] == 'Polygon':
            coords_list = [geo['coordinates']]
        else:
            continue
        for coords in coords_list:
            x = np.array([float(c[0]) for c in coords[0]])
            y = np.array([float(c[1]) for c in coords[0]])
            poly = Polygon(x, y, False, 0)
            annotations.append(
                poly)
            if 'classification' in annotation['properties']:
                class_names.append(
                    annotation['properties']['classification']['name'])
            else:
                class_names.append('')
            if 'name' in annotation['properties']:
                anno_names.append(annotation['properties']['name'])
            else:
                anno_names.append(
                    'ROI_'+str(len(anno_names)))
    return annotations, class_names, anno_names

def write_annotations(ofname, annos, class_name=None):
    annotations = []
    for anno in annos:
        anno_name = 'ROI_'+str(len(annotations))
        annotations.append(anno_to_json(anno, class_name, anno_name))
    json.dump(annotations, open(ofname, 'w'))

def append_annotations(ofname, annos, class_name=None, anno_names=None):
    annotations = []
    orig_annos, class_names, anno_names = read_annotations(ofname)
    for i in range(len(orig_annos)):
        if class_name == class_names[i]:
            continue
        annotations.append(anno_to_json(
            orig_annos[i], class_names[i], anno_names[i]))
    for i in range(len(annos)):
        if anno_names is None:
            anno_name = 'ROI_'+str(len(annotations))
        else:
            anno_name = anno_names[i]
        annotations.append(anno_to_json(annos[i], class_name, anno_name))
    json.dump(annotations, open(ofname, 'w'))

#
# end of file
